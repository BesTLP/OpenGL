# 光照篇(Lighting)

# 1.颜色

我们在现实生活中看到某一物体的颜色并不是这个物体真正拥有的颜色，而是它所<font color='A2CD5A'>**反射的(Reflected)**</font>颜色。

<font color='87CEFA'>**白色的阳光实际上是所有可见颜色的集合**</font>，物体吸收了其中的大部分颜色。它仅反射了代表物体颜色的部分，<font color='87CEFA'>**被反射颜色的组合就是我们所感知到的颜色**</font>。

我们将光源设置为白色，然后让<font color='87CEFA'>**光源的颜色值和物体的颜色值相乘**</font>，就可以得到物体最终反射的颜色。

```c++
glm::vec3 lightColor(1.0f, 1.0f, 1.0f);
glm::vec3 objectColor(1.0f, 0.5f, 0.31f);
glm::vec3 result = lightColor * objectColor; // keep same
```

如果我们设置为绿色的光源

```c++
glm::vec3 lightColor(0.0f, 1.0f, 0.0f);
glm::vec3 objectColor(1.0f, 0.5f, 0.31f);
glm::vec3 result = lightColor * objectColor; // (0.0f, 0.5f, 0.0f);
```

<font color='87CEFA'>**吸收了光线中一半的绿色值，但仍然也反射了一半的绿色值。**</font>玩具现在看上去是<font color='CD96CD'>**深绿色(Dark-greenish)**</font>的。

我们使用两个立方体的箱子，一个作为投光的对象，另一个代表光源。

但是我们需要对光源立方体重新设置一个VAO，如果和其它的物体使用同一个VAO的话，可能也会影响到灯的修改。

```c++
unsigned int LightVAO;
glGenVertexArrays(1, &LightVAO);
glBindVertexArray(LightVAO);
glBindBuffer(GL_ARRAY_BUFFER, VBO); // 我们可以直接使用VBO中的数据而不用glBufferData()
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);
```

这样我们就可以创建一个光源了，然后修改一下片段着色器

```c++
#version 330 core

out vec4 FragColor;

uniform vec3 lightColor;
uniform vec3 objectColor;

void main()
{
	FragColor = vec4(LightColor * ObjectColor, 1.0f);
}
```

```c++
shader.setVec3("lightColor", 1.0f, 1.0f, 1.0f);
shader.setVec3("objectColor", 1.0f, 0.5f, 0.31f);
```

但是实际上如果我们这样做的话，灯的片段着色器会和物体的一样被附着上是珊瑚红，因此我们需要为等重新创建新的着色器。

顶点着色器保持一致，但是片段着色器构建新的。

```c++
#version 330 core

out vec4 FragColor;
void main()
{
	FragColor = vec4(1.0f);
}
```

# 2.基础光照

<font color='A2CD5A'>**风氏光照模型(Phong Lighting Model)。**</font>主要结构由3个分量组成：<font color='A2CD5A'>**环境(Ambient)、漫反射(Diffuse)和镜面(Specular)光照**</font>。

![image-20241215160520285](C:\Users\windows\AppData\Roaming\Typora\typora-user-images\image-20241215160520285.png)

- 环境光照(Ambient Lighting)：即使在黑暗的情况下，世界上通常也仍然有一些光亮（月亮、远处的光），<font color='87CEFA'>**所以物体几乎永远不会是完全黑暗的。**</font>为了模拟这个，我们会使用一个环境光照常量，它永远会给物体一些颜色。
- 漫反射光照(Diffuse Lighting)：模拟光源对物体的方向性影响(Directional Impact)。它是风氏光照模型中视觉上最显著的分量。<font color='87CEFA'>**物体的某一部分越是正对着光源，它就会越亮。**</font>
- 镜面光照(Specular Lighting)：<font color='87CEFA'>**模拟有光泽物体上面出现的亮点。**</font>镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。

## 环境光照

环境光照是一个简化的全局照明模型，我们使用一个较小的常量（光照颜色），添加到物体片段的最终颜色之中。

我们只需要对光的颜色乘以一个较小的常量环境银子，再乘以物体的颜色，就是最终片段的颜色。

```c++
float ambientStength = 0.1;
vec3 ambient = ambientStrength * lightColor;

vec3 result = ambient * objectColor;
FragColor = vec4(result, 1.0f);
```

## 漫反射光照

漫反射光照使物体上与光线方向越接近的片段能从光源处获得更多的亮度。

![image-20241215162624161](C:\Users\windows\AppData\Roaming\Typora\typora-user-images\image-20241215162624161.png)

为了测量光线和片段的角度，我们使用一个叫做<font color='A2CD5A'>**法向量**</font>(Normal Vector)的东西，它是<font color='87CEFA'>**垂直于片段表面的一个向量**</font>

我们直接使用两个单位向量的点乘，就可以来计算光线对片段颜色的影响了，因为同向的点乘标量值为1

- 法向量：一个垂直于顶点表面的向量。
- 定向的光线：作为光源的位置与片段的位置之间向量差的方向向量。为了计算这个光线，我们需要光的位置向量和片段的位置向量。

### 法向量

顶点本身并没有表面，我们可以利用它周围的顶点来计算出这个顶点的表面，也可以直接将法线数据添加到顶点数组之中。

```c++
float vertices[] = 
{
    -0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,
     0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f, 
     0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f, 
     0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f, 
    -0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f, 
    -0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f, 

    -0.5f, -0.5f,  0.5f,  0.0f,  0.0f, 1.0f,
     0.5f, -0.5f,  0.5f,  0.0f,  0.0f, 1.0f,
     0.5f,  0.5f,  0.5f,  0.0f,  0.0f, 1.0f,
     0.5f,  0.5f,  0.5f,  0.0f,  0.0f, 1.0f,
    -0.5f,  0.5f,  0.5f,  0.0f,  0.0f, 1.0f,
    -0.5f, -0.5f,  0.5f,  0.0f,  0.0f, 1.0f,

    -0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,
    -0.5f,  0.5f, -0.5f, -1.0f,  0.0f,  0.0f,
    -0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,
    -0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,
    -0.5f, -0.5f,  0.5f, -1.0f,  0.0f,  0.0f,
    -0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,

     0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,
     0.5f,  0.5f, -0.5f,  1.0f,  0.0f,  0.0f,
     0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,
     0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,
     0.5f, -0.5f,  0.5f,  1.0f,  0.0f,  0.0f,
     0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,

    -0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,
     0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,
     0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,
     0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,

    -0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,
     0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,
     0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,
     0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,
    -0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,
    -0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f
};
```

对于光源我们不需要获取对应的法向量信息，但是对应的<font color='CD96CD'>**stride**</font>步长还是要进行修改。

```c++
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)) );

	unsigned int lightCubeVAO;
	glGenVertexArrays(1, &lightCubeVAO);
	glBindVertexArray(lightCubeVAO);

	glBindBuffer(GL_ARRAY_BUFFER, VBO);

	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
	glEnableVertexAttribArray(0);
```

将法向量的信息从顶点着色器传递到片段着色器之中。

```c++
// Vertex Shader;
layout(location = 1) in vec3 aNormal;
out vec3 Normal;
void main()
{
	Normal = aNormal;
};

// Fragment Shader;
in vec3 Normal;
```

## 计算漫反射光照

除了片段的法向量之外，我们还需要获取光源的位置向量和片段的位置向量。

```c++
uniform vec3 lightPos;
```

但是我们还需要获取片段的位置，我们需要获取的是在世界空间中的顶点位置，将顶点的位置属性乘以模型矩阵来将其变换到世界空间坐标。

```c++
out vec3 FragPos;
FragPos = vec3(model * vec4(Pos, 1.0));
```

然后用片段着色器来接收即可

```c++
in vec3 FragPos;
```

```c++
#version 330 core

in vec3 FragPos;
in vec3 Normal;

out vec4 FragColor;

uniform vec3 lightColor;
uniform vec3 objectColor;
uniform vec3 lightPos;
void main()
{
	vec3 norm = normalize(Normal);
	vec3 lightDir = normalize(lightPos - FragPos);
	float diff = max(dot(norm, lightDir), 0.0);
	vec3 diffuse = diff * lightColor;

	float ambientStrength = 0.1;
	vec3 ambient = ambientStrength * lightColor;

	vec3 result = (ambient + diffuse) * objectColor;
	FragColor = vec4(result, 1.0);
}
```

## More

按道理来说，目前片段着色器中的计算都是在世界空间坐标中进行的，所以我们应该将法向量也转换为世界空间坐标，但是这不是乘以一个模型矩阵就可以实现的。

法向量只是一个方向向量，不能表达空间中的特定位置。同时，法向量没有齐次坐标（顶点位置中的w分量）

<font color='87CEFA'>**位移不应该影响到法向量。**</font>因此，如果我们打算把法向量乘以一个模型矩阵，我们就要从矩阵中移除位移部分，<font color='87CEFA'>**只选用模型矩阵左上角3×3的矩阵**</font>（注意，我们也可以把法向量的w分量设置为0，再乘以4×4矩阵；这同样可以移除位移）。<font color='87CEFA'>**对于法向量，我们只希望对它实施缩放和旋转变换。**</font>

如果模型矩阵执行了不等比缩放，那么顶点的改变会导致法向量不再垂直于表面。

![image-20241215171628441](C:\Users\windows\AppData\Roaming\Typora\typora-user-images\image-20241215171628441.png)

修复这个行为的诀窍是使用一个为法向量专门定制的模型矩阵。这个矩阵称之为<font color='A2CD5A'>**法线矩阵**</font>(Normal Matrix)，它使用了一些线性代数的操作来移除对法向量错误缩放的影响。

法线矩阵被定义为「模型矩阵左上角3x3部分的<font color='87CEFA'>**逆矩阵**</font>的<font color='87CEFA'>**转置矩阵**</font>」

```c++
Normal = mat3(transpose(inverse(model))) * aNormal;
```

<font color='FFD00'>**矩阵求逆是一项对于着色器开销很大的运算，因为它必须在场景中的每一个顶点上进行，所以应该尽可能地避免在着色器中进行求逆运算。以学习为目的的话这样做还好，但是对于一个高效的应用来说，你最好先在CPU上计算出法线矩阵，再通过uniform把它传递给着色器（就像模型矩阵一样）。**</font>

## 镜面光照

镜面光照不仅决定于光的方向向量和物体的法向量，也决定于玩家的观察方向。

![image-20241215172234590](C:\Users\windows\AppData\Roaming\Typora\typora-user-images\image-20241215172234590.png)

我们<font color='87CEFA'>**通过根据法向量翻折入射光的方向来计算反射向量**</font>。然后我们<font color='87CEFA'>**计算反射向量与观察方向的角度差**</font>，它们之间夹角越小，镜面光的作用就越大。

```c++
uniform vec3 viewPos;
lightingShader.setVec3("viewPos", camera.Position);
```

计算视线方向向量，和对应沿着法线轴的反射向量：

```c++
vec3 viewDir = normalize(viewPos - FragPos);
vec3 reflectDir = reflect(-lightDir, norm);
```

`reflect`函数要求第一个向量是从光源指向片段位置的向量，但是`lightDir`当前正好相反。

计算镜面分量：

```c++
float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
vec3 specular = specularStrength * spec * lightColor;
```

我们先计算<font color='87CEFA'>**视线方向与反射方向的点乘**</font>（并确保它不是负值），然后取它的32次幂。这个32是高光的<font color='A2CD5A'>**反光度**</font>(Shininess)。一个物体的<font color='87CEFA'>**反光度越高，反射光的能力越强，散射得越少**</font>，高光点就会越小。在下面的图片里，你会看到不同反光度的视觉效果影响：

![image-20241215190031072](C:\Users\windows\AppData\Roaming\Typora\typora-user-images\image-20241215190031072.png)

```c++
vec3 norm = normalize(Normal);
vec3 lightDir = normalize(lightPos - FragPos);
float diff = max(dot(norm, lightDir), 0.0);
vec3 diffuse = diff * lightColor;

float ambientStrength = 0.1;
vec3 ambient = ambientStrength * lightColor;

float specularStrength = 0.5;
vec3 viewDir = normalize(viewPos - FragPos);
vec3 reflectDir = reflect(-lightDir, norm);
float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
vec3 specular = specularStrength * spec * lightColor;

vec3 result = (ambient + diffuse + specular) * objectColor;
FragColor = vec4(result, 1.0);
```

![image-20241215190547711](C:\Users\windows\AppData\Roaming\Typora\typora-user-images\image-20241215190547711.png)

在光照着色器的早期，开发者曾经在顶点着色器中实现风氏光照模型。在顶点着色器中做光照的优势是，相比片段来说，顶点要少得多，因此会更高效，所以（开销大的）光照计算频率会更低。然而，顶点着色器中的最终颜色值是仅仅只是那个顶点的颜色值，片段的颜色值是由插值光照颜色所得来的。结果就是这种光照看起来不会非常真实，除非使用了大量顶点。

<font color='FFD00'>**在顶点着色器中实现的风氏光照模型叫做Gouraud着色(Gouraud Shading)，而不是风氏着色(Phong Shading)**</font>。记住，由于插值，这种光照看起来有点逊色。风氏着色能产生更平滑的光照效果。

![img](https://learnopengl-cn.github.io/img/02/02/basic_lighting_gouruad.png)

# 材质

三个光照分量定义一个<font color='A2CD5A'>**材质颜色**</font>(Material Color)：<font color='A2CD5A'>**环境光照**</font>(Ambient Lighting)、<font color='A2CD5A'>**漫反射光照**</font>(Diffuse Lighting)和<font color='A2CD5A'>**镜面光照**</font>(Specular Lighting)。再添加一个<font color='A2CD5A'>**反光度**</font>(Shininess)分量，结合上述的三个颜色，我们就有了全部所需的材质属性了：

```c++
#version 330 core
struct Material
{
	vec3 ambient;
	vec3 diffuse;
	vec3 specular;
	float shininess;
};

uniform Material material;
```

`ambient:`环境光照下这个<font color='87CEFA'>**表面反射的颜色**</font>，通常与表面颜色相同。

`diffuse`:定义了在<font color='87CEFA'>**漫反射光照**</font>下表面的颜色

`specular:`表面上<font color='87CEFA'>**镜面高光**</font>的颜色

`shininess:`影响<font color='87CEFA'>**镜面高光的散射**</font>/半径

以下数据来源：

[OpenGL/VRML Materials](http://devernay.free.fr/cours/opengl/materials.html)

| Name           | Ambient  |          |          | Diffuse  |            |            | Specular   |            |            | Shininess  |
| -------------- | -------- | -------- | -------- | -------- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- |
| emerald        | 0.0215   | 0.1745   | 0.0215   | 0.07568  | 0.61424    | 0.07568    | 0.633      | 0.727811   | 0.633      | 0.6        |
| jade           | 0.135    | 0.2225   | 0.1575   | 0.54     | 0.89       | 0.63       | 0.316228   | 0.316228   | 0.316228   | 0.1        |
| obsidian       | 0.05375  | 0.05     | 0.06625  | 0.18275  | 0.17       | 0.22525    | 0.332741   | 0.328634   | 0.346435   | 0.3        |
| pearl          | 0.25     | 0.20725  | 0.20725  | 1        | 0.829      | 0.829      | 0.296648   | 0.296648   | 0.296648   | 0.088      |
| ruby           | 0.1745   | 0.01175  | 0.01175  | 0.61424  | 0.04136    | 0.04136    | 0.727811   | 0.626959   | 0.626959   | 0.6        |
| turquoise      | 0.1      | 0.18725  | 0.1745   | 0.396    | 0.74151    | 0.69102    | 0.297254   | 0.30829    | 0.306678   | 0.1        |
| brass          | 0.329412 | 0.223529 | 0.027451 | 0.780392 | 0.568627   | 0.113725   | 0.992157   | 0.941176   | 0.807843   | 0.21794872 |
| bronze         | 0.2125   | 0.1275   | 0.054    | 0.714    | 0.4284     | 0.18144    | 0.393548   | 0.271906   | 0.166721   | 0.2        |
| chrome         | 0.25     | 0.25     | 0.25     | 0.4      | 0.4        | 0.4        | 0.774597   | 0.774597   | 0.774597   | 0.6        |
| copper         | 0.19125  | 0.0735   | 0.0225   | 0.7038   | 0.27048    | 0.0828     | 0.256777   | 0.137622   | 0.086014   | 0.1        |
| gold           | 0.24725  | 0.1995   | 0.0745   | 0.75164  | 0.60648    | 0.22648    | 0.628281   | 0.555802   | 0.366065   | 0.4        |
| silver         | 0.19225  | 0.19225  | 0.19225  | 0.50754  | 0.50754    | 0.50754    | 0.508273   | 0.508273   | 0.508273   | 0.4        |
| black plastic  | 0.0      | 0.0      | 0.0      | 0.01     | 0.01       | 0.01       | 0.50       | 0.50       | 0.50       | .25        |
| cyan plastic   | 0.0      | 0.1      | 0.06     | 0.0      | 0.50980392 | 0.50980392 | 0.50196078 | 0.50196078 | 0.50196078 | .25        |
| green plastic  | 0.0      | 0.0      | 0.0      | 0.1      | 0.35       | 0.1        | 0.45       | 0.55       | 0.45       | .25        |
| red plastic    | 0.0      | 0.0      | 0.0      | 0.5      | 0.0        | 0.0        | 0.7        | 0.6        | 0.6        | .25        |
| white plastic  | 0.0      | 0.0      | 0.0      | 0.55     | 0.55       | 0.55       | 0.70       | 0.70       | 0.70       | .25        |
| yellow plastic | 0.0      | 0.0      | 0.0      | 0.5      | 0.5        | 0.0        | 0.60       | 0.60       | 0.50       | .25        |
| black rubber   | 0.02     | 0.02     | 0.02     | 0.01     | 0.01       | 0.01       | 0.4        | 0.4        | 0.4        | .078125    |
| cyan rubber    | 0.0      | 0.05     | 0.05     | 0.4      | 0.5        | 0.5        | 0.04       | 0.7        | 0.7        | .078125    |
| green rubber   | 0.0      | 0.05     | 0.0      | 0.4      | 0.5        | 0.4        | 0.04       | 0.7        | 0.04       | .078125    |
| red rubber     | 0.05     | 0.0      | 0.0      | 0.5      | 0.4        | 0.4        | 0.7        | 0.04       | 0.04       | .078125    |
| white rubber   | 0.05     | 0.05     | 0.05     | 0.5      | 0.5        | 0.5        | 0.7        | 0.7        | 0.7        | .078125    |
| yellow rubber  | 0.05     | 0.05     | 0.0      | 0.5      | 0.5        | 0.4        | 0.7        | 0.7        | 0.04       | .078125    |

# 设置材质

```c++
#version 330 core

struct Material
{
	vec3 ambient;
	vec3 diffuse;
	vec3 specular;
	float shininess;
};
uniform Material material;
uniform vec3 lightColor;
uniform vec3 lightPos;
uniform vec3 viewPos;

in vec3 FragPos;
in vec3 Normal;

out vec4 FragColor;

void main()
{
    // 环境光
	vec3 ambient = lightColor * material.ambient;
    
	// 漫反射
	vec3 norm = normalize(Normal);
	vec3 lightDir = normalize(lightPos - FragPos);
	float diff = max(dot(norm, lightDir), 0.0);
	vec3 diffuse = lightColor * (diff * material.diffuse);

    // 镜面光
	vec3 viewDir = normalize(viewPos -	FragPos);
	vec3 reflectDir = reflect(-lightDir, norm);
	float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
	vec3 specular = lightColor * (spec * material.specular);

	vec3 result = ambient + diffuse + specular;
	FragColor = vec4(result, 1.0);
}
```

根据材质的颜色我们可以得到物体在光照下的真正颜色，物体的每个材质属性都乘上了各自对应的光照分量。

![image-20250218095552559](C:\Users\windows\AppData\Roaming\Typora\typora-user-images\image-20250218095552559.png)

但是光照过于强烈，这是由于我们总是用`lightColor`去乘以每一个光照分量，我们目前设置的`lightColor`为`vec3(1.0f)`，因此光照非常强烈。

我们可以类似于物体的材质属性，为光照也添加几个分量

```c++
struct Light
{
    vec3 position;
    
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
}

uniform Light light;

void main()
{
    // 得到的光照分量计算结果需要额外乘以Light的属性
    vec3 ambient = light.ambient * material.ambient;
    vec3 diffuse = light.diffuse * (diff * material.diffuse);
    vec3 specular = light.specular * (spec * material.specular);
}

```

![image-20250218100245170](C:\Users\windows\AppData\Roaming\Typora\typora-user-images\image-20250218100245170.png)

结合`glfwGetTime()`可以实现光源颜色的变化

```c++
glm::vec3 lightColor = glm::vec3(1.0f);
lightColor.x = sin(glfwGetTime() * 2.0f);
lightColor.y = sin(glfwGetTime() * 0.7f);
lightColor.z = sin(glfwGetTime() * 1.3f);
glm::vec3 ambientColor = lightColor * glm::vec3(0.5f);
glm::vec3 diffuseColor = lightColor * glm::vec3(0.2f);
objectShader.setVec3("light.ambient", ambientColor);
objectShader.setVec3("light.diffuse", diffuseColor);
```

# 练习

- 你能做到这件事吗，改变光照颜色导致改变光源立方体的颜色？

就像随机变色的代码一样。

- 你能像教程一开始那样，通过定义相应的材质来模拟现实世界的物体吗？注意[材质表格](http://devernay.free.fr/cours/opengl/materials.html)中的环境光值与漫反射值不一样，它们没有考虑光照的强度。要想正确地设置它们的值，你需要将所有的光照强度都设置为`vec3(1.0)`，这样才能得到一致的输出：[参考解答](https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/3.2.materials_exercise1/materials_exercise1.cpp)：青色塑料(Cyan Plastic)容器。

```c++
// cyan plastic Material
objectShader.setVec3("material.ambient", 0.0f, 0.1f, 0.06f);
objectShader.setVec3("material.diffuse", 0.0f, 0.50980392f, 0.50980392f);
objectShader.setVec3("material.specular", 0.50196078f, 0.50196078f, 0.50196078f);
objectShader.setFloat("material.shininess", 0.25f);

objectShader.setVec3("light.ambient", 1.0f, 1.0f, 1.0f);
objectShader.setVec3("light.diffuse", 1.0f, 1.0f, 1.0f);
objectShader.setVec3("light.specular", 1.0f, 1.0f, 1.0f);
```

# 光照贴图

